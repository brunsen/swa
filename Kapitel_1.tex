\subsection{Developer}
Viele Betriebe wie zum Beispiel Versicherungen sind heutzutage beinahe vollständig auf Software angewiesen, die ihre Arbeit korrekt abbildet und vereinfacht. Diese Software wird von Entwicklern (Developern) mit Hilfe von Abstraktion und Programmiersprachen hergestellt. Damit die Software auch den Ansprüchen der Anwender entspricht, nimmt der Entwickler die Anforderungen vom Anwender beziehungsweise dem Auftraggeber entgegen und setzt diese in Programmcode um. Zusätzlich ist es die Aufgabe des Entwicklers den geschriebenen Programmcode sowohl manuell als auch programmatisch zu testen und damit ein korrektes Verhalten der Anwendung sicherzustellen.\\
Das Ergebnis der Arbeit eines Entwicklers ist ein Stück Software, das dem Kunden als Installationsdatei oder Ähnlichem übergeben wird. Der Entwickler selbst ist nicht dafür zuständig, dass die Anwendung in den laufenden Betrieb des Kunden integriert wird.

\subsection{Operation}
Unter Operations werden im herkömmlichen Sinne Mitarbeiter mit IT-Kenntnissen verstanden, deren Ziel es ist, den täglichen IT-Betrieb am laufen zu halten. Zu ihren Aufgaben gehören unter anderem die Bereitstellung von Hardware für Mitarbeiter des Betriebes sowie die Verwaltung von Servern. Sie sind ebenfalls dafür zuständig, Software unter anderem auf die Geräte der Mitarbeiter und auf die Server des Betriebes zu spielen. Dabei kann die Software entweder käuflich erworben oder im eigenen Unternehmen entwickelt worden sein. Dies wird in der Regel mit Skripten realisiert, die Operations selber anlegen.\\
Zu einer Software, die kommerziell erworben wurde, gibt es in der Regel so gennante Service Level Agreements, die eine mit dem Softwarehersteller vereinbarte Leistungsqualität der einzusetzenden Software beschreiben. Ein Beispiel hierfür wäre, dass ein Hersteller von einer Cloudbasierten Anwendung seinem Kunden verspricht, dass die Anwendung mit einer bestimmten Anzahl an Anfragen innerhalb einer definierten Zeitspanne zurecht kommt, sodass keine Ausfälle entstehen. Innerhalb eines Betriebes überwachen Operations die Service Level Agreements und melden gegebenenfalls Verstöße ihren Vorgesetzten oder dem Hersteller der Software. \\
Um die Einhaltung der Service Level Agreements zu überprüfen, wird die Software mit Hilfe von Monitoring und Logging Werkzeugen überwacht. Dabei vermitteln die Werkzeuge des Monitorings den Operations wichtige Informationen wie zum Beispiel den Speicherverbrauch und den Status der laufenden Anwendungen. Mit Hilfe der Logging Werkzeuge, können die Operations auf Fehler innerhalb der Anwendung schließen. Für den Fall, dass die Umgebung der Anwendung falsch konfiguriert ist, wird dies üblicherweise in Log-Dateien geschrieben, die den Operations zur Verfügung stehen. \\
Wie bereits erwähnt, ist das Ziel von Operations den IT-Betrieb am laufen zu halten. Dies wird in der Regel als Business Continuity bezeichnet. Allerdings ist dies nicht nur mit einer für die Anwendung passend konfigurierten Umgebung möglich. Die Rechner und Server eines Betriebes müssen nach Außen abgesichert werden, um Ausfälle durch Schadangriffe so gut wie möglich zu unterbinden. Dies ist ebenfalls ein Aufgabenbereich von Operations.

\section{Agile Softwareentwicklung}
Neben der klassischen Softwareentwicklung, die nach starren Modellen wie zum Beispiel dem Wasserfallmodell arbeitet, hat sich in den letzten Jahren die agile Softwareentwicklung etabliert. Die agile Softwareentwicklung mit agilen Vorgehensweisen wie zum Beispiel Scrum oder Xtreme Programming, bindet den Kunden stärker in den Entwicklungsprozess ein und bietet die Möglichkeit schon während der Entwicklung auf das die Software Einfluß zu nehemen. \\
Len Bass hat bei der agilen Softwareentwicklung drei Phasen identifiziert, auf die im folgenden eingegangen wird. Die erste Phase ist die sogenannte Inception Phase. In dieser Phase werden unter anderem die Anforderungen an die Software aufgenommen und erste Modellierungsarbeiten betrieben. Zustäzlich wird in dieser Phase ein Release Plan erstellt, der mit dem Kunden abgestimmt wird.\\
Die zweite Phase ist die so genannte Construction Phase. In dieser Phase wird die Software nach agilen Methoden wie zum Beispiel Scrum entwickelt. Das Ergebnis dieser Phase ist ein Software Artifakt, das dem Kunden übergeben werden kann. \\
Die finale Phase ist die Transition Phase. In dieser Phase wird das zuvor hergestellte Artifakt beim Kunden auf die Rechner beziehungsweise Server gespielt und somit in den laufenden Betrieb integriert.

\section{Monolith}
Unter einem Monolithen wird in der Softwareentwicklung ein Architekturstil verstanden, bei dem die Software auf höchster Ebene nur als eine einzelne Komponente gesehen wird. Monolithen sind in der Regel sehr große Komponenten, die mehr als 50.000 Zeilen an Programmcode aufweisen. Darüber hinaus enthalten Monolithen die gesamte Geschäftslogik einer Anwendung. Monolithen entstehen implizit, wenn kein spezieller Architekturstil vorgegeben wird, da die Codebasis mit der Zeit durch weitere Entwicklungsarbeiten wächst. Häufig sind monolithisch entworfene Anwendungen im Serverbereich von Webanwendungen aufzufinden. \\
Anwendungen, die nach diesem Stil entworfen wurden, weisen einige Nachteile auf. Zum einen erfordert jede Änderung (zum Beispiel eine Fehlerkorrektur) ein erneutes Deployment der gesamten Anwendung. Zusätzlich skalieren monolithische Anwendung schlecht. Sollte zum Beispiel eine logische Einheit des Monolithen wie die Datenpersistierung nicht unter der aktuellen Last bestehen, müsste eine zweite Instanz der gesamten Anwendung erzeugt werden, um die Last zu bewältigen. Dies ist nicht optimal, da eigentlich nur die Datenpersistierung zusätzliche Instanzen benötigen würde. \\
Ein weiterer Nachteil, der durch die monolithische Architektur entsteht, findet sich im Release einer neuen Version wieder. Da bei einem erneuten Deployment die gesamte Anwendung erneut auf die Rechner beziehungsweise Server gespielt werden muss, sind diese in der Zeit des Deployments nicht verfügbar. Dies kann je nach Anwendungsfeld zu einem Ausfall an Einnahmen führen. Zum Beispiel könnte ein Händler im Internet keine Produkte verkaufen, während seine Anwendung nicht verfügbar ist. Aus diesem Grund werden neue Versionen einer monolithischen Anwendung so selten wie nötig auf die Systeme gespielt. Dies führt wiederum dazu, dass eine neue Version nicht bei jedem neuen Feature entsteht, sondern erst mit einer Vielzahl neuer Features. Die vielen neuen Features können allerdings Inkompatibilitäten in der Anwendung erzeugen sowie zu einer erhöhten Ferleranfälligkeit führen. Daher erfoderdet eine neue Version einen sehr hohen Aufwand beim Testen der Anwendung. Darüber hinaus kann eine neue Version auch eine völlig anders konfigurierte Umgebung erfordern, was den Aufwand einer neuen Version ebenfalls erhöht. All dies erfordert einen sehr hohen Koordinationsaufwand und eine langfristige Planung, was wiederum zu einem langsamen Release der Anwendung führt.